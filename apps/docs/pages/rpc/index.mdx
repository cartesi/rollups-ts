# RPC Client

This library provides a typed JSON-RPC client for the Cartesi Rollups v2 [JSON-RPC API](https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/cartesi/rollups-node/refs/tags/v2.0.0-alpha.3/internal/jsonrpc/jsonrpc-discover.json&uiSchema[appBar][ui:title]=Cartesi&uiSchema[appBar][ui:logoUrl]=https://cartesi.io/favicon.svg&uiSchema[appBar][ui:transports]=false&uiSchema[appBar][ui:input]=false&uiSchema[appBar][ui:edit]=false&uiSchema[appBar][ui:examplesDropdown]=false&uiSchema[appBar][ui:splitView]=false).
The API currently provides read-only access to 5 entities managed by a rollups node: applications, epochs, inputs, outputs and Reports.

There are RPC methods to get a single entity and methods to list a paginated collection of entities, for the 5 entities above:

```
cartesi_getApplication
cartesi_getEpoch
cartesi_getInput
cartesi_getOutput
cartesi_getReport

cartesi_listApplications
cartesi_listEpochs
cartesi_listInputs
cartesi_listOutputs
cartesi_listReports
```

## Applications

Cartesi Rollups nodes can manage several deployed applications at the same time.
Each application has a corresponding Cartesi Machine, starting from a genesis machine, and evolving with each new input addressed to that application.

Deployment of new applications is currently managed by node operators on behalf of application developers.
An application have an onchain representation, which can be deployed by the application developer or the node operator, but the offchain Cartesi machine have to be registered in the node by the node operator.

## Epochs

Cartesi rollups is an optimistic rollups solution based on fraud proofs.
These proofs are generated every interval called epoch, and a commitment is posted onchain.
These commitments can then be challenged by Cartesi's upcoming fraud proof system.
Once epochs are finalized executable outputs that were generated within that epoch can then be executed.

## Inputs

Inputs are "transactions" that are addressed to an application and fed into the application Cartesi machine, making it transition from state A to state B.
Inputs are either sent directly to the application base layer InputBox smart contract, or to an alternative data availability solution.

Cartesi is working on integrations with [Espresso](http://espressosys.com) and [Avail](https://www.availproject.org).

## Outputs

Outputs are pieces of information with attached proofs that are generated by applications.
There are two basic types of outputs: notices and vouchers.

Notices are information only data with attached proofs that can be used on the base layer to prove some fact stated by the Cartesi rollup application.

Vouchers represent not only information but executable actions that can be performed on the base layer, through the execution of any function of any smart contract, or simply an ETH transfer.

Both notices and vouchers proofs are generated at the end of an epoch.

## Reports

Reports are pieces of information with no attached proof.

## State changes

Two additional methods are provided by the API that are useful for identifying state changes: `cartesi_getLastAcceptedEpoch` and `cartesi_getProcessedInputCount`.
These can be used for example by polling mechanisms to detect application state changes, to then take further actions.

## Pagination

All the list methods, [cartesi_listApplications](/rpc/cartesi_listApplications), [cartesi_listEpochs](/rpc/cartesi_listEpochs), [cartesi_listInputs](/rpc/cartesi_listInputs), [cartesi_listOutputs](/rpc/cartesi_listOutputs) and [cartesi_listReports](/rpc/cartesi_listReports), are paginated.
They all receive a `limit` and an `offset` number param in the request, and return a `pagination` object in the return, in addition to a `data` array of entity objects.

```ts
type Pagination = {
    total_count: number;
    limit: number;
    offset: number;
};

type PaginatedReturnType<T> = {
    data: T[];
    pagination: Pagination;
};
```
